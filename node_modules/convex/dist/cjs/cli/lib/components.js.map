{
  "version": 3,
  "sources": ["../../../../src/cli/lib/components.ts"],
  "sourcesContent": ["import path from \"path\";\nimport { Context, changeSpinner, logError } from \"../../bundler/context.js\";\nimport {\n  ProjectConfig,\n  configFromProjectConfig,\n  readProjectConfig,\n} from \"./config.js\";\nimport { finishPush, startPush, waitForSchema } from \"./deploy2.js\";\nimport { version } from \"../version.js\";\nimport { PushOptions, runNonComponentsPush } from \"./push.js\";\nimport { ensureHasConvexDependency, functionsDir } from \"./utils.js\";\nimport {\n  bundleDefinitions,\n  bundleImplementations,\n  componentGraph,\n} from \"./components/definition/bundle.js\";\nimport { isComponentDirectory } from \"./components/definition/directoryStructure.js\";\nimport {\n  doFinalComponentCodegen,\n  doInitialComponentCodegen,\n} from \"./codegen.js\";\nimport {\n  AppDefinitionConfig,\n  ComponentDefinitionConfig,\n} from \"./deployApi/definitionConfig.js\";\nimport { typeCheckFunctionsInMode } from \"./typecheck.js\";\nimport { withTmpDir } from \"../../bundler/fs.js\";\nimport { ROOT_DEFINITION_FILENAME } from \"./components/constants.js\";\n\nexport async function runPush(ctx: Context, options: PushOptions) {\n  const { configPath, projectConfig } = await readProjectConfig(ctx);\n  const convexDir = functionsDir(configPath, projectConfig);\n  const componentRootPath = path.resolve(\n    path.join(convexDir, ROOT_DEFINITION_FILENAME),\n  );\n  if (ctx.fs.exists(componentRootPath)) {\n    await runComponentsPush(ctx, options, configPath, projectConfig);\n  } else {\n    await runNonComponentsPush(ctx, options, configPath, projectConfig);\n  }\n}\n\nexport async function runComponentsPush(\n  ctx: Context,\n  options: PushOptions,\n  configPath: string,\n  projectConfig: ProjectConfig,\n) {\n  const verbose = options.verbose || options.dryRun;\n  await ensureHasConvexDependency(ctx, \"push\");\n\n  if (options.dryRun) {\n    logError(ctx, \"dryRun not allowed yet\");\n    await ctx.crash(1, \"fatal\");\n  }\n  if (options.debugBundlePath) {\n    logError(ctx, \"debugBundlePath not allowed yet\");\n    await ctx.crash(1, \"fatal\");\n  }\n\n  const convexDir = functionsDir(configPath, projectConfig);\n\n  // '.' means use the process current working directory, it's the default behavior.\n  // Spelling it out here to be explicit for a future where this code can run\n  // from other directories.\n  // In esbuild the working directory is used to print error messages and resolving\n  // relatives paths passed to it. It generally doesn't matter for resolving imports,\n  // imports are resolved from the file where they are written.\n  const absWorkingDir = path.resolve(\".\");\n  const isComponent = isComponentDirectory(ctx, convexDir, true);\n  if (isComponent.kind === \"err\") {\n    logError(\n      ctx,\n      `Invalid component root directory (${isComponent.why}): ${convexDir}`,\n    );\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n  const rootComponent = isComponent.component;\n\n  changeSpinner(ctx, \"Traversing component definitions...\");\n  // Create a list of relevant component directories. These are just for knowing\n  // while directories to bundle in bundleDefinitions and bundleImplementations.\n  // This produces a bundle in memory as a side effect but it's thrown away.\n  //\n  // This is the very first time we traverse the component graph.\n  // We're just traversing to discover\n  const { components, dependencyGraph } = await componentGraph(\n    ctx,\n    absWorkingDir,\n    rootComponent,\n    verbose,\n  );\n\n  changeSpinner(ctx, \"Generating server code...\");\n  await withTmpDir(async (tmpDir) => {\n    await doInitialComponentCodegen(ctx, tmpDir, rootComponent, options);\n    for (const directory of components.values()) {\n      await doInitialComponentCodegen(ctx, tmpDir, directory, options);\n    }\n  });\n\n  changeSpinner(ctx, \"Bundling component definitions...\");\n  // This bundles everything but the actual function definitions\n  const {\n    appDefinitionSpecWithoutImpls,\n    componentDefinitionSpecsWithoutImpls,\n  } = await bundleDefinitions(\n    ctx,\n    absWorkingDir,\n    dependencyGraph,\n    rootComponent,\n    // Note that this *includes* the root component.\n    [...components.values()],\n  );\n\n  const { config: localConfig } = await configFromProjectConfig(\n    ctx,\n    projectConfig,\n    configPath,\n    verbose,\n  );\n  changeSpinner(ctx, \"Bundling component schemas and implementations...\");\n  const { appImplementation, componentImplementations } =\n    await bundleImplementations(\n      ctx,\n      rootComponent,\n      [...components.values()],\n      projectConfig.node.externalPackages,\n      verbose,\n    );\n\n  // We're just using the version this CLI is running with for now.\n  // This could be different than the version of `convex` the app runs with\n  // if the CLI is installed globally.\n  // TODO: This should be the version of the `convex` package used by each\n  // component, and may be different for each component.\n  const udfServerVersion = version;\n\n  const appDefinition: AppDefinitionConfig = {\n    ...appDefinitionSpecWithoutImpls,\n    auth: localConfig.authConfig || null,\n    ...appImplementation,\n    udfServerVersion,\n  };\n\n  const componentDefinitions: ComponentDefinitionConfig[] = [];\n  for (const componentDefinition of componentDefinitionSpecsWithoutImpls) {\n    const impl = componentImplementations.filter(\n      (impl) =>\n        // convert from ComponentPath\n        path.resolve(rootComponent.path, impl.definitionPath) ===\n        componentDefinition.definitionPath,\n    )[0];\n    if (!impl) {\n      console.log(\n        `missing! couldn't find ${componentDefinition.definitionPath} in ${componentImplementations.map((impl) => path.resolve(rootComponent.path, impl.definitionPath)).toString()}`,\n      );\n      return await ctx.crash(1, \"fatal\");\n    }\n    componentDefinitions.push({\n      ...componentDefinition,\n      ...impl,\n      udfServerVersion,\n    });\n  }\n\n  const startPushResponse = await startPush(\n    ctx,\n    options.url,\n    {\n      adminKey: options.adminKey,\n      dryRun: false,\n      functions: projectConfig.functions,\n      appDefinition,\n      componentDefinitions,\n      nodeDependencies: appImplementation.externalNodeDependencies,\n    },\n    verbose,\n  );\n\n  verbose && console.log(\"startPush:\");\n  verbose && console.dir(startPushResponse, { depth: null });\n\n  changeSpinner(ctx, \"Finalizing code generation...\");\n  await withTmpDir(async (tmpDir) => {\n    await doFinalComponentCodegen(\n      ctx,\n      tmpDir,\n      rootComponent,\n      rootComponent,\n      startPushResponse,\n    );\n    for (const directory of components.values()) {\n      await doFinalComponentCodegen(\n        ctx,\n        tmpDir,\n        rootComponent,\n        directory,\n        startPushResponse,\n      );\n    }\n  });\n\n  changeSpinner(ctx, \"Running TypeScript...\");\n  await typeCheckFunctionsInMode(ctx, options.typecheck, rootComponent.path);\n  for (const directory of components.values()) {\n    await typeCheckFunctionsInMode(ctx, options.typecheck, directory.path);\n  }\n\n  changeSpinner(ctx, \"Waiting for schema...\");\n  await waitForSchema(ctx, options.adminKey, options.url, startPushResponse);\n\n  const finishPushResponse = await finishPush(\n    ctx,\n    options.adminKey,\n    options.url,\n    startPushResponse,\n  );\n  verbose && console.log(\"finishPush:\", finishPushResponse);\n}\n"],
  "mappings": "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",
  "names": ["path", "impl"]
}
