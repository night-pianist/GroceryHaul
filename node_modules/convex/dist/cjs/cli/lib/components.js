"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var components_exports = {};
__export(components_exports, {
  runComponentsPush: () => runComponentsPush,
  runPush: () => runPush
});
module.exports = __toCommonJS(components_exports);
var import_path = __toESM(require("path"), 1);
var import_context = require("../../bundler/context.js");
var import_config = require("./config.js");
var import_deploy2 = require("./deploy2.js");
var import_version = require("../version.js");
var import_push = require("./push.js");
var import_utils = require("./utils.js");
var import_bundle = require("./components/definition/bundle.js");
var import_directoryStructure = require("./components/definition/directoryStructure.js");
var import_codegen = require("./codegen.js");
var import_typecheck = require("./typecheck.js");
var import_fs = require("../../bundler/fs.js");
var import_constants = require("./components/constants.js");
async function runPush(ctx, options) {
  const { configPath, projectConfig } = await (0, import_config.readProjectConfig)(ctx);
  const convexDir = (0, import_utils.functionsDir)(configPath, projectConfig);
  const componentRootPath = import_path.default.resolve(
    import_path.default.join(convexDir, import_constants.ROOT_DEFINITION_FILENAME)
  );
  if (ctx.fs.exists(componentRootPath)) {
    await runComponentsPush(ctx, options, configPath, projectConfig);
  } else {
    await (0, import_push.runNonComponentsPush)(ctx, options, configPath, projectConfig);
  }
}
async function runComponentsPush(ctx, options, configPath, projectConfig) {
  const verbose = options.verbose || options.dryRun;
  await (0, import_utils.ensureHasConvexDependency)(ctx, "push");
  if (options.dryRun) {
    (0, import_context.logError)(ctx, "dryRun not allowed yet");
    await ctx.crash(1, "fatal");
  }
  if (options.debugBundlePath) {
    (0, import_context.logError)(ctx, "debugBundlePath not allowed yet");
    await ctx.crash(1, "fatal");
  }
  const convexDir = (0, import_utils.functionsDir)(configPath, projectConfig);
  const absWorkingDir = import_path.default.resolve(".");
  const isComponent = (0, import_directoryStructure.isComponentDirectory)(ctx, convexDir, true);
  if (isComponent.kind === "err") {
    (0, import_context.logError)(
      ctx,
      `Invalid component root directory (${isComponent.why}): ${convexDir}`
    );
    return await ctx.crash(1, "invalid filesystem data");
  }
  const rootComponent = isComponent.component;
  (0, import_context.changeSpinner)(ctx, "Traversing component definitions...");
  const { components, dependencyGraph } = await (0, import_bundle.componentGraph)(
    ctx,
    absWorkingDir,
    rootComponent,
    verbose
  );
  (0, import_context.changeSpinner)(ctx, "Generating server code...");
  await (0, import_fs.withTmpDir)(async (tmpDir) => {
    await (0, import_codegen.doInitialComponentCodegen)(ctx, tmpDir, rootComponent, options);
    for (const directory of components.values()) {
      await (0, import_codegen.doInitialComponentCodegen)(ctx, tmpDir, directory, options);
    }
  });
  (0, import_context.changeSpinner)(ctx, "Bundling component definitions...");
  const {
    appDefinitionSpecWithoutImpls,
    componentDefinitionSpecsWithoutImpls
  } = await (0, import_bundle.bundleDefinitions)(
    ctx,
    absWorkingDir,
    dependencyGraph,
    rootComponent,
    // Note that this *includes* the root component.
    [...components.values()]
  );
  const { config: localConfig } = await (0, import_config.configFromProjectConfig)(
    ctx,
    projectConfig,
    configPath,
    verbose
  );
  (0, import_context.changeSpinner)(ctx, "Bundling component schemas and implementations...");
  const { appImplementation, componentImplementations } = await (0, import_bundle.bundleImplementations)(
    ctx,
    rootComponent,
    [...components.values()],
    projectConfig.node.externalPackages,
    verbose
  );
  const udfServerVersion = import_version.version;
  const appDefinition = {
    ...appDefinitionSpecWithoutImpls,
    auth: localConfig.authConfig || null,
    ...appImplementation,
    udfServerVersion
  };
  const componentDefinitions = [];
  for (const componentDefinition of componentDefinitionSpecsWithoutImpls) {
    const impl = componentImplementations.filter(
      (impl2) => (
        // convert from ComponentPath
        import_path.default.resolve(rootComponent.path, impl2.definitionPath) === componentDefinition.definitionPath
      )
    )[0];
    if (!impl) {
      console.log(
        `missing! couldn't find ${componentDefinition.definitionPath} in ${componentImplementations.map((impl2) => import_path.default.resolve(rootComponent.path, impl2.definitionPath)).toString()}`
      );
      return await ctx.crash(1, "fatal");
    }
    componentDefinitions.push({
      ...componentDefinition,
      ...impl,
      udfServerVersion
    });
  }
  const startPushResponse = await (0, import_deploy2.startPush)(
    ctx,
    options.url,
    {
      adminKey: options.adminKey,
      dryRun: false,
      functions: projectConfig.functions,
      appDefinition,
      componentDefinitions,
      nodeDependencies: appImplementation.externalNodeDependencies
    },
    verbose
  );
  verbose && console.log("startPush:");
  verbose && console.dir(startPushResponse, { depth: null });
  (0, import_context.changeSpinner)(ctx, "Finalizing code generation...");
  await (0, import_fs.withTmpDir)(async (tmpDir) => {
    await (0, import_codegen.doFinalComponentCodegen)(
      ctx,
      tmpDir,
      rootComponent,
      rootComponent,
      startPushResponse
    );
    for (const directory of components.values()) {
      await (0, import_codegen.doFinalComponentCodegen)(
        ctx,
        tmpDir,
        rootComponent,
        directory,
        startPushResponse
      );
    }
  });
  (0, import_context.changeSpinner)(ctx, "Running TypeScript...");
  await (0, import_typecheck.typeCheckFunctionsInMode)(ctx, options.typecheck, rootComponent.path);
  for (const directory of components.values()) {
    await (0, import_typecheck.typeCheckFunctionsInMode)(ctx, options.typecheck, directory.path);
  }
  (0, import_context.changeSpinner)(ctx, "Waiting for schema...");
  await (0, import_deploy2.waitForSchema)(ctx, options.adminKey, options.url, startPushResponse);
  const finishPushResponse = await (0, import_deploy2.finishPush)(
    ctx,
    options.adminKey,
    options.url,
    startPushResponse
  );
  verbose && console.log("finishPush:", finishPushResponse);
}
//# sourceMappingURL=components.js.map
