{
  "version": 3,
  "sources": ["../../../../src/server/components/index.ts"],
  "sourcesContent": ["import {\n  Infer,\n  ObjectType,\n  PropertyValidators,\n  convexToJson,\n} from \"../../values/index.js\";\nimport { AnyFunctionReference } from \"../api.js\";\nimport { EmptyObject } from \"../registration.js\";\nimport {\n  AppDefinitionAnalysis,\n  ComponentDefinitionAnalysis,\n  ComponentDefinitionType,\n  HttpMount,\n} from \"./definition.js\";\nimport { extractReferencePath, toReferencePath } from \"./reference.js\";\n\n/**\n * An object of this type should be the default export of a\n * component.config.ts file in a component definition directory.\n *\n * @internal\n */ // eslint-disable-next-line @typescript-eslint/ban-types\nexport type ComponentDefinition<Args extends PropertyValidators = EmptyObject> =\n  {\n    /**\n     * Install a component with the given definition in this component definition.\n     *\n     * Takes a component definition, an optional name, and the args it requires.\n     *\n     * For editor tooling this method expects a {@link ComponentDefinition}\n     * but at runtime the object that is imported will be a {@link ImportedComponentDefinition}\n     */\n    install<Definition extends ComponentDefinition<any>>(\n      definition: Definition,\n      options: {\n        name?: string;\n        // TODO we have to do the \"arguments are optional if empty, otherwise required\"\n        args?: ObjectType<ExtractArgs<Definition>>;\n      },\n    ): InstalledComponent<Definition>;\n\n    /**\n     * Mount a component's HTTP router at a given path prefix.\n     */\n    mountHttp(pathPrefix: string, component: InstalledComponent<any>): void;\n\n    // TODO this will be needed once components are responsible for building interfaces for themselves\n    /**\n     * @internal\n     */\n    __args: Args;\n  };\n\n/**\n * An object of this type should be the default export of a\n * app.config.ts file in a component definition directory.\n *\n * @internal\n */\nexport type AppDefinition = {\n  /**\n   * Install a component with the given definition in this component definition.\n   *\n   * Takes a component definition, an optional name, and the args it requires.\n   *\n   * For editor tooling this method expects a {@link ComponentDefinition}\n   * but at runtime the object that is imported will be a {@link ImportedComponentDefinition}\n   */\n  install<Definition extends ComponentDefinition<any>>(\n    definition: Definition,\n    options: {\n      name?: string;\n      args?: ObjectType<ExtractArgs<Definition>>;\n    },\n  ): InstalledComponent<Definition>;\n\n  /**\n   * Mount a component's HTTP router at a given path prefix.\n   */\n  mountHttp(pathPrefix: string, component: InstalledComponent<any>): void;\n};\n\ntype CommonDefinitionData = {\n  _isRoot: boolean;\n  _childComponents: [\n    string,\n    ImportedComponentDefinition,\n    Record<string, any>,\n  ][];\n  _httpMounts: Record<string, HttpMount>;\n};\n\ntype ComponentDefinitionData = CommonDefinitionData & {\n  _args: PropertyValidators;\n  _name: string;\n};\ntype AppDefinitionData = CommonDefinitionData;\n\ntype ExtractArgs<T> = T extends ComponentDefinition<infer P> ? P : never;\n\n/**\n * Used to refer to an already-installed component.\n */\nclass InstalledComponent<Definition extends ComponentDefinition<any>> {\n  /**\n   * @internal\n   */\n  _definition: Definition;\n\n  /**\n   * @internal\n   */\n  [toReferencePath]: string;\n\n  constructor(definition: Definition, name: string) {\n    this._definition = definition;\n    this[toReferencePath] = `_reference/childComponent/${name}`;\n  }\n}\n\nfunction install<Definition extends ComponentDefinition<any>>(\n  this: CommonDefinitionData,\n  definition: Definition,\n  options: {\n    name?: string;\n    args?: Infer<ExtractArgs<Definition>>;\n  } = {},\n): InstalledComponent<Definition> {\n  // At runtime an imported component will have this shape.\n  const importedComponentDefinition =\n    definition as unknown as ImportedComponentDefinition;\n  if (typeof importedComponentDefinition.componentDefinitionPath !== \"string\") {\n    throw new Error(\n      \"Component definition does not have the required componentDefinitionPath property. This code only works in Convex runtime.\",\n    );\n  }\n  const name =\n    options.name ||\n    importedComponentDefinition.componentDefinitionPath.split(\"/\").pop()!;\n  this._childComponents.push([\n    name,\n    importedComponentDefinition,\n    options.args || {},\n  ]);\n\n  return new InstalledComponent(definition, name);\n}\n\nfunction mountHttp(\n  this: CommonDefinitionData,\n  pathPrefix: string,\n  component: InstalledComponent<any>,\n) {\n  if (!pathPrefix.startsWith(\"/\")) {\n    throw new Error(`Path prefix '${pathPrefix}' does not start with a /`);\n  }\n  if (!pathPrefix.endsWith(\"/\")) {\n    throw new Error(`Path prefix '${pathPrefix}' must end with a /`);\n  }\n  if (this._httpMounts[pathPrefix]) {\n    throw new Error(`Path '${pathPrefix}' is already mounted.`);\n  }\n  const path = extractReferencePath(component);\n  if (!path) {\n    throw new Error(\"`mountHttp` must be called with an `InstalledComponent`.\");\n  }\n  this._httpMounts[pathPrefix] = path;\n}\n\n// At runtime when you import a ComponentDefinition, this is all it is\n/**\n * @internal\n */\nexport type ImportedComponentDefinition = {\n  componentDefinitionPath: string;\n};\n\nfunction exportAppForAnalysis(\n  this: ComponentDefinition<any> & AppDefinitionData,\n): AppDefinitionAnalysis {\n  const definitionType = { type: \"app\" as const };\n  const childComponents = serializeChildComponents(this._childComponents);\n  return {\n    definitionType,\n    childComponents: childComponents as any,\n    httpMounts: this._httpMounts,\n    exports: { type: \"branch\", branch: [] },\n  };\n}\n\nfunction serializeChildComponents(\n  childComponents: [string, ImportedComponentDefinition, Record<string, any>][],\n): {\n  name: string;\n  path: string;\n  args: [string, { type: \"value\"; value: string }][];\n}[] {\n  return childComponents.map(([name, definition, p]) => {\n    const args: [string, { type: \"value\"; value: string }][] = [];\n    for (const [name, value] of Object.entries(p)) {\n      args.push([\n        name,\n        { type: \"value\", value: JSON.stringify(convexToJson(value)) },\n      ]);\n    }\n    // we know that components carry this extra information\n    const path = definition.componentDefinitionPath;\n    if (!path)\n      throw new Error(\n        \"no .componentPath for component definition \" +\n          JSON.stringify(definition, null, 2),\n      );\n\n    return {\n      name: name!,\n      path: path!,\n      args,\n    };\n  });\n}\n\nfunction exportComponentForAnalysis(\n  this: ComponentDefinition<any> & ComponentDefinitionData,\n): ComponentDefinitionAnalysis {\n  const args: [string, { type: \"value\"; value: string }][] = Object.entries(\n    this._args,\n  ).map(([name, validator]) => [\n    name,\n    {\n      type: \"value\",\n      value: JSON.stringify(validator.json),\n    },\n  ]);\n  const definitionType: ComponentDefinitionType = {\n    type: \"childComponent\" as const,\n    name: this._name,\n    args,\n  };\n  const childComponents = serializeChildComponents(this._childComponents);\n\n  return {\n    name: this._name,\n    definitionType,\n    childComponents: childComponents as any,\n    httpMounts: this._httpMounts,\n    exports: { type: \"branch\", branch: [] },\n  };\n}\n\n// This is what is actually contained in a ComponentDefinition.\ntype RuntimeComponentDefinition = Exclude<ComponentDefinition<any>, \"__args\"> &\n  ComponentDefinitionData & {\n    export: () => ComponentDefinitionAnalysis;\n  };\ntype RuntimeAppDefinition = AppDefinition &\n  AppDefinitionData & {\n    export: () => AppDefinitionAnalysis;\n  };\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function defineComponent<Args extends PropertyValidators = {}>(\n  name: string,\n  options: { args?: Args } = {},\n): ComponentDefinition<Args> {\n  const ret: RuntimeComponentDefinition = {\n    _isRoot: false,\n    _name: name,\n    _args: options.args || {},\n    _childComponents: [],\n    _httpMounts: {},\n\n    export: exportComponentForAnalysis,\n    install,\n    mountHttp,\n\n    // pretend to conform to ComponentDefinition, which temporarily expects __args\n    ...({} as { __args: any }),\n  };\n  return ret as ComponentDefinition<Args>;\n}\n\n/**\n * Experimental - DO NOT USE.\n */\n// TODO Make this not experimental.\nexport function defineApp(): AppDefinition {\n  const ret: RuntimeAppDefinition = {\n    _isRoot: true,\n    _childComponents: [],\n    _httpMounts: {},\n\n    export: exportAppForAnalysis,\n    install,\n    mountHttp,\n  };\n  return ret as AppDefinition;\n}\n\ntype AnyInterfaceType = {\n  [key: string]: AnyInterfaceType;\n} & AnyFunctionReference;\nexport type AnyComponentReference = Record<string, AnyInterfaceType>;\n\ntype AnyChildComponents = Record<string, AnyComponentReference>;\n\n/**\n * @internal\n */\nexport function currentSystemUdfInComponent(\n  componentId: string,\n): AnyComponentReference {\n  return {\n    [toReferencePath]: `_reference/currentSystemUdfInComponent/${componentId}`,\n  };\n}\n\nfunction createChildComponents(\n  root: string,\n  pathParts: string[],\n): AnyChildComponents {\n  const handler: ProxyHandler<object> = {\n    get(_, prop: string | symbol) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createChildComponents(root, newParts);\n      } else if (prop === toReferencePath) {\n        if (pathParts.length < 1) {\n          const found = [root, ...pathParts].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`${root}.childComponent.functionName\\`. Found: \\`${found}\\``,\n          );\n        }\n        return `_reference/childComponent/` + pathParts.join(\"/\");\n      } else {\n        return undefined;\n      }\n    },\n  };\n  return new Proxy({}, handler);\n}\n\n/**\n * @internal\n */\nexport const appGeneric = () => createChildComponents(\"app\", []);\n\n/**\n * @internal\n */\nexport type AnyApp = AnyChildComponents;\n\n/**\n * @internal\n */\nexport const componentGeneric = () => createChildComponents(\"component\", []);\n\n/**\n * @internal\n */\nexport type AnyComponent = AnyChildComponents;\n"],
  "mappings": ";AAAA;AAAA,EAIE;AAAA,OACK;AASP,SAAS,sBAAsB,uBAAuB;AAyFtD,MAAM,mBAAgE;AAAA,EAWpE,YAAY,YAAwB,MAAc;AAChD,SAAK,cAAc;AACnB,SAAK,eAAe,IAAI,6BAA6B;AAAA,EACvD;AACF;AANG;AAQH,SAAS,QAEP,YACA,UAGI,CAAC,GAC2B;AAEhC,QAAM,8BACJ;AACF,MAAI,OAAO,4BAA4B,4BAA4B,UAAU;AAC3E,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,QAAM,OACJ,QAAQ,QACR,4BAA4B,wBAAwB,MAAM,GAAG,EAAE,IAAI;AACrE,OAAK,iBAAiB,KAAK;AAAA,IACzB;AAAA,IACA;AAAA,IACA,QAAQ,QAAQ,CAAC;AAAA,EACnB,CAAC;AAED,SAAO,IAAI,mBAAmB,YAAY,IAAI;AAChD;AAEA,SAAS,UAEP,YACA,WACA;AACA,MAAI,CAAC,WAAW,WAAW,GAAG,GAAG;AAC/B,UAAM,IAAI,MAAM,gBAAgB,qCAAqC;AAAA,EACvE;AACA,MAAI,CAAC,WAAW,SAAS,GAAG,GAAG;AAC7B,UAAM,IAAI,MAAM,gBAAgB,+BAA+B;AAAA,EACjE;AACA,MAAI,KAAK,YAAY,UAAU,GAAG;AAChC,UAAM,IAAI,MAAM,SAAS,iCAAiC;AAAA,EAC5D;AACA,QAAM,OAAO,qBAAqB,SAAS;AAC3C,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC5E;AACA,OAAK,YAAY,UAAU,IAAI;AACjC;AAUA,SAAS,uBAEgB;AACvB,QAAM,iBAAiB,EAAE,MAAM,MAAe;AAC9C,QAAM,kBAAkB,yBAAyB,KAAK,gBAAgB;AACtE,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,YAAY,KAAK;AAAA,IACjB,SAAS,EAAE,MAAM,UAAU,QAAQ,CAAC,EAAE;AAAA,EACxC;AACF;AAEA,SAAS,yBACP,iBAKE;AACF,SAAO,gBAAgB,IAAI,CAAC,CAAC,MAAM,YAAY,CAAC,MAAM;AACpD,UAAM,OAAqD,CAAC;AAC5D,eAAW,CAACA,OAAM,KAAK,KAAK,OAAO,QAAQ,CAAC,GAAG;AAC7C,WAAK,KAAK;AAAA,QACRA;AAAA,QACA,EAAE,MAAM,SAAS,OAAO,KAAK,UAAU,aAAa,KAAK,CAAC,EAAE;AAAA,MAC9D,CAAC;AAAA,IACH;AAEA,UAAM,OAAO,WAAW;AACxB,QAAI,CAAC;AACH,YAAM,IAAI;AAAA,QACR,gDACE,KAAK,UAAU,YAAY,MAAM,CAAC;AAAA,MACtC;AAEF,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAEA,SAAS,6BAEsB;AAC7B,QAAM,OAAqD,OAAO;AAAA,IAChE,KAAK;AAAA,EACP,EAAE,IAAI,CAAC,CAAC,MAAM,SAAS,MAAM;AAAA,IAC3B;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,OAAO,KAAK,UAAU,UAAU,IAAI;AAAA,IACtC;AAAA,EACF,CAAC;AACD,QAAM,iBAA0C;AAAA,IAC9C,MAAM;AAAA,IACN,MAAM,KAAK;AAAA,IACX;AAAA,EACF;AACA,QAAM,kBAAkB,yBAAyB,KAAK,gBAAgB;AAEtE,SAAO;AAAA,IACL,MAAM,KAAK;AAAA,IACX;AAAA,IACA;AAAA,IACA,YAAY,KAAK;AAAA,IACjB,SAAS,EAAE,MAAM,UAAU,QAAQ,CAAC,EAAE;AAAA,EACxC;AACF;AAgBO,gBAAS,gBACd,MACA,UAA2B,CAAC,GACD;AAC3B,QAAM,MAAkC;AAAA,IACtC,SAAS;AAAA,IACT,OAAO;AAAA,IACP,OAAO,QAAQ,QAAQ,CAAC;AAAA,IACxB,kBAAkB,CAAC;AAAA,IACnB,aAAa,CAAC;AAAA,IAEd,QAAQ;AAAA,IACR;AAAA,IACA;AAAA;AAAA,IAGA,GAAI,CAAC;AAAA,EACP;AACA,SAAO;AACT;AAMO,gBAAS,YAA2B;AACzC,QAAM,MAA4B;AAAA,IAChC,SAAS;AAAA,IACT,kBAAkB,CAAC;AAAA,IACnB,aAAa,CAAC;AAAA,IAEd,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,EACF;AACA,SAAO;AACT;AAYO,gBAAS,4BACd,aACuB;AACvB,SAAO;AAAA,IACL,CAAC,eAAe,GAAG,0CAA0C;AAAA,EAC/D;AACF;AAEA,SAAS,sBACP,MACA,WACoB;AACpB,QAAM,UAAgC;AAAA,IACpC,IAAI,GAAG,MAAuB;AAC5B,UAAI,OAAO,SAAS,UAAU;AAC5B,cAAM,WAAW,CAAC,GAAG,WAAW,IAAI;AACpC,eAAO,sBAAsB,MAAM,QAAQ;AAAA,MAC7C,WAAW,SAAS,iBAAiB;AACnC,YAAI,UAAU,SAAS,GAAG;AACxB,gBAAM,QAAQ,CAAC,MAAM,GAAG,SAAS,EAAE,KAAK,GAAG;AAC3C,gBAAM,IAAI;AAAA,YACR,4CAA4C,gDAAgD;AAAA,UAC9F;AAAA,QACF;AACA,eAAO,+BAA+B,UAAU,KAAK,GAAG;AAAA,MAC1D,OAAO;AACL,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO,IAAI,MAAM,CAAC,GAAG,OAAO;AAC9B;AAKO,aAAM,aAAa,MAAM,sBAAsB,OAAO,CAAC,CAAC;AAUxD,aAAM,mBAAmB,MAAM,sBAAsB,aAAa,CAAC,CAAC;",
  "names": ["name"]
}
