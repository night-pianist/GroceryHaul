import { GenericId } from "./index.js";
import { GenericValidator } from "./validator.js";
import { JSONValue } from "./value.js";
type TableNameFromType<T> = T extends GenericId<infer TableName> ? TableName : string;
/**
 * Avoid using `instanceof BaseValidator`; this is inheritence for code reuse
 * not type heirarchy.
 */
declare abstract class BaseValidator<Type, IsOptional extends OptionalProperty = "required", FieldPaths extends string = never> {
    readonly type: Type;
    readonly isOptional: IsOptional;
    readonly fieldPaths: FieldPaths;
    readonly isConvexValidator: true;
    constructor({ isOptional }: {
        isOptional: IsOptional;
    });
    /** @deprecated - use isOptional instead */
    get optional(): boolean;
}
export declare class VId<Type, IsOptional extends OptionalProperty = "required"> extends BaseValidator<Type, IsOptional> {
    readonly tableName: TableNameFromType<Type>;
    readonly kind: "id";
    constructor({ isOptional, tableName, }: {
        isOptional: IsOptional;
        tableName: TableNameFromType<Type>;
    });
}
export declare class VFloat64<Type = number, IsOptional extends OptionalProperty = "required"> extends BaseValidator<Type, IsOptional> {
    readonly kind: "float64";
}
export declare class VInt64<Type = bigint, IsOptional extends OptionalProperty = "required"> extends BaseValidator<Type, IsOptional> {
    readonly kind: "int64";
}
export declare class VBoolean<Type = boolean, IsOptional extends OptionalProperty = "required"> extends BaseValidator<Type, IsOptional> {
    readonly kind: "boolean";
}
export declare class VBytes<Type = ArrayBuffer, IsOptional extends OptionalProperty = "required"> extends BaseValidator<Type, IsOptional> {
    readonly kind: "bytes";
}
export declare class VString<Type = string, IsOptional extends OptionalProperty = "required"> extends BaseValidator<Type, IsOptional> {
    readonly kind: "string";
}
export declare class VNull<Type = null, IsOptional extends OptionalProperty = "required"> extends BaseValidator<Type, IsOptional> {
    readonly kind: "null";
}
export declare class VAny<Type = any, IsOptional extends OptionalProperty = "required", FieldPaths extends string = string> extends BaseValidator<Type, IsOptional, FieldPaths> {
    readonly kind: "any";
}
/**
 * Validator for an object that produces indexed types.
 *
 * If the value validator is not optional, it produces a `Record` type, which is an alias
 * for `{[key: K]: V}`.
 *
 * If the value validator is optional, it produces a mapped object type,
 * with optional keys: `{[key in K]?: V}`.
 *
 * This is used within the validator builder, {@link v}.
 */
export declare class VObject<Type, Fields extends Record<string, GenericValidator>, IsOptional extends OptionalProperty = "required", FieldPaths extends string = {
    [Property in keyof Fields]: JoinFieldPaths<Property & string, Fields[Property]["fieldPaths"]> | Property;
}[keyof Fields] & string> extends BaseValidator<Type, IsOptional, FieldPaths> {
    readonly type: Type;
    readonly fields: Fields;
    readonly kind: "object";
    constructor({ isOptional, fields, }: {
        isOptional: IsOptional;
        fields: Fields;
    });
}
export declare class VLiteral<Type, IsOptional extends OptionalProperty = "required"> extends BaseValidator<Type, IsOptional> {
    readonly value: Type;
    readonly type: Type;
    readonly kind: "literal";
    constructor({ isOptional, value }: {
        isOptional: IsOptional;
        value: Type;
    });
}
export declare class VArray<Type, Element extends Validator<any, "required", any>, IsOptional extends OptionalProperty = "required"> extends BaseValidator<Type, IsOptional> {
    readonly element: Element;
    readonly kind: "array";
    constructor({ isOptional, element, }: {
        isOptional: IsOptional;
        element: Element;
    });
}
export declare class VRecord<Type, Key extends Validator<string, "required", any>, Value extends Validator<any, "required", any>, IsOptional extends OptionalProperty = "required", FieldPaths extends string = string> extends BaseValidator<Type, IsOptional, FieldPaths> {
    readonly key: Key;
    readonly value: Value;
    readonly kind: "record";
    constructor({ isOptional, key, value, }: {
        isOptional: IsOptional;
        key: Key;
        value: Value;
    });
}
export declare class VUnion<Type, T extends Validator<any, "required", any>[], IsOptional extends OptionalProperty = "required", FieldPaths extends string = T[number]["fieldPaths"]> extends BaseValidator<Type, IsOptional, FieldPaths> {
    readonly members: T;
    readonly kind: "union";
    constructor({ isOptional, members }: {
        isOptional: IsOptional;
        members: T;
    });
}
export type VOptional<T extends Validator<any, OptionalProperty, any>> = T extends VId<infer Type, OptionalProperty> ? VId<Type | undefined, "optional"> : T extends VString<infer Type, OptionalProperty> ? VString<Type | undefined, "optional"> : T extends VFloat64<infer Type, OptionalProperty> ? VFloat64<Type | undefined, "optional"> : T extends VInt64<infer Type, OptionalProperty> ? VInt64<Type | undefined, "optional"> : T extends VBoolean<infer Type, OptionalProperty> ? VBoolean<Type | undefined, "optional"> : T extends VNull<infer Type, OptionalProperty> ? VNull<Type | undefined, "optional"> : T extends VAny<infer Type, OptionalProperty> ? VAny<Type | undefined, "optional"> : T extends VLiteral<infer Type, OptionalProperty> ? VLiteral<Type | undefined, "optional"> : T extends VBytes<infer Type, OptionalProperty> ? VBytes<Type | undefined, "optional"> : T extends VObject<infer Type, infer Fields, OptionalProperty, infer FieldPaths> ? VObject<Type | undefined, Fields, "optional", FieldPaths> : T extends VArray<infer Type, infer Element, OptionalProperty> ? VArray<Type | undefined, Element, "optional"> : T extends VRecord<infer Type, infer Key, infer Value, OptionalProperty, infer FieldPaths> ? VRecord<Type | undefined, Key, Value, "optional", FieldPaths> : T extends VUnion<infer Type, infer Members, OptionalProperty, infer FieldPaths> ? VUnion<Type | undefined, Members, "optional", FieldPaths> : never;
/**
 * Type representing whether a property in an object is optional or required.
 *
 * @public
 */
export type OptionalProperty = "optional" | "required";
/**
 * A validator for a Convex value.
 *
 * This should be constructed using the validator builder, {@link v}.
 *
 * A validator encapsulates:
 * - The TypeScript type of this value.
 * - Whether this field should be optional if it's included in an object.
 * - The TypeScript type for the set of index field paths that can be used to
 * build indexes on this value.
 * - A JSON representation of the validator.
 *
 * Specific types of validators contain additional information: for example
 * an `ArrayValidator` contains an `element` property with the validator
 * used to validate each element of the list. Use the shared 'kind' property
 * to identity the type of validator.
 *
 * More validators can be added in future releases so an exhaustive
 * switch statement on validator `kind` should be expected to break
 * in future releases of Convex.
 *
 * @public
 */
export type Validator<Type, IsOptional extends OptionalProperty = "required", FieldPaths extends string = never> = VId<Type, IsOptional> | VString<Type, IsOptional> | VFloat64<Type, IsOptional> | VInt64<Type, IsOptional> | VBoolean<Type, IsOptional> | VNull<Type, IsOptional> | VAny<Type, IsOptional> | VLiteral<Type, IsOptional> | VBytes<Type, IsOptional> | VObject<Type, Record<string, Validator<any, OptionalProperty, any>>, IsOptional, FieldPaths> | VArray<Type, Validator<any, "required", any>, IsOptional> | VRecord<Type, Validator<string, "required", any>, Validator<any, "required", any>, IsOptional, FieldPaths> | VUnion<Type, Validator<any, "required", any>[], IsOptional, FieldPaths>;
/**
 * Join together two index field paths.
 *
 * This is used within the validator builder, {@link v}.
 * @public
 */
export type JoinFieldPaths<Start extends string, End extends string> = `${Start}.${End}`;
export type ObjectFieldType = {
    fieldType: ValidatorJSON;
    optional: boolean;
};
export type ValidatorJSON = {
    type: "null";
} | {
    type: "number";
} | {
    type: "bigint";
} | {
    type: "boolean";
} | {
    type: "string";
} | {
    type: "bytes";
} | {
    type: "any";
} | {
    type: "literal";
    value: JSONValue;
} | {
    type: "id";
    tableName: string;
} | {
    type: "array";
    value: ValidatorJSON;
} | {
    type: "record";
    keys: ValidatorJSON;
    values: ObjectFieldType;
} | {
    type: "object";
    value: Record<string, ObjectFieldType>;
} | {
    type: "union";
    value: ValidatorJSON[];
};
export {};
//# sourceMappingURL=validators.d.ts.map